package ownable.persons;import java.math.BigInteger;import java.util.HashSet;import java.util.NoSuchElementException;import java.util.Set;import ownable.exceptions.IllegalOwnerException;import ownable.ownings.Car;import ownable.ownings.Dog;import ownable.ownings.Ownable;import ownable.ownings.Painting;import be.kuleuven.cs.som.annotate.Raw;/** * A class of persons involving a relation with things they own. *  * @invar   Each person must can have each of its ownings as *          its owning. *          | for each ownable in Ownable: *          |   if (hasAsOwning(ownable) *          |     then canHaveAsOwning(ownable) *  * @version  2.0 * @author   Eric Steegmans */public class Person {	/**	 * Initialize this new person with no ownings.	 *	 * @post    This new person has no ownings.	 *          | new.getNbOwnings() == 0	 * @post    This new person is not terminated.	 *          | ! new.isTerminated()	 */	public Person() {	}	/**	 * Check whether this person has been terminated.	 */	@Raw public boolean isTerminated() {		return (ownings == null);	}	/**	 * Terminate this person.	 *	 * @post    This person is terminated.	 *          | new.isTerminated()	 * @post    Each of the ownings of this person no longer has	 *          an owner.	 *          | for each ownable in Ownable:	 *          |	if (this.hasAsOwning(ownable)	 *          |     then (! (new ownable).hasOwner())	 */	public void terminate() {		if (!isTerminated()) {			// Cannot iterate directly over the set of ownings, because			// the iterator then throws ConcurrentModificationException.			Ownable[] owningsCopy = new Ownable[getNbOwnings()];			ownings.toArray(owningsCopy);			for (Ownable ownable : owningsCopy)				ownable.removeOwner();			setIsTerminated();		}	}	/**	 * Set the terminated-state for this person according to true.	 * 	 * @post    The terminated-state of this person is true.	 *          | new.isTerminated() == true	 */	protected void setIsTerminated() {		this.ownings = null;	}	/**	 * Check whether this person has the given ownable as one of	 * its ownings.	 *	 * @param   ownable	 *          The ownable to check.	 */	@Raw public boolean hasAsOwning(Ownable ownable) {		return (ownings != null) && ownings.contains(ownable);	}	/**	 * Check whether this person can have the given ownable	 * as one of its ownings.	 * 	 * @param   ownable	 *          The ownable to check.	 * @return  True if the given ownable is effective, if that	 *          ownable can have this person as its owner, and either	 *          this person does not have the given ownable as one of	 *          its ownings or the given ownable references this	 *          person as its owner; false otherwise.	 *          | result ==	 *          |   (ownable != null) &&	 *          |   ownable.canHaveAsOwner(this) &&	 *          |   ( (! hasAsOwning(ownable)) ||	 *          |     (ownable.getOwner() == this) )	 */	@Raw public boolean canHaveAsOwning(@Raw Ownable ownable) {		return (ownable != null) && (ownable.canHaveAsOwner(this))			&& ((!hasAsOwning(ownable)) || (ownable.getOwner() == this));	}	/**	 * Return the number of ownings of this person.	 * 	 * @return  The total number of ownings of this person.	 *          result ==	 *          |   { ownable:Ownable | hasAsOwning(ownable) }.size()	 */	public int getNbOwnings() {		return ownings.size();	}	/**	 * Add the given ownable to the ownings of this person.	 *	 * @param   ownable	 *          The ownable to be added.	 * @effect  The owner of the given ownable is changed to this person.	 *          | ownable.changeOwnerTo(this)	 * @throws  IllegalArgumentException [must]	 *          The given ownable is not effective.	 *          | ownable == null	 */	public void addToOwnings(Ownable ownable) throws IllegalOwnerException,			IllegalArgumentException {		try {			ownable.changeOwnerTo(this);		}		catch (NullPointerException exc) {			assert (ownable == null);			throw new IllegalArgumentException(				"The given ownable is not effective");		}	}	/**	 * Remove the given ownable from the ownings of this person.	 *	 * @param   ownable	 *          The ownable to be removed.	 * @effect  The owner of the given ownable is removed.	 *          | ownable.removeOwner()	 * @throws  IllegalArgumentException [must]	 *          The given ownable is not effective.	 *          | ownable == null	 * @throws  IllegalArgumentException [must]	 *          The given ownable is effective and this person does not have the	 *          given ownable as one of its ownings.	 *          | (ownable != null) && (! this.hasAsOwning(ownable))	 */	public void removeFromOwnings(Ownable ownable)			throws IllegalOwnerException, IllegalArgumentException {		if (ownable == null)			throw new IllegalArgumentException(				"The given ownable is not effective!");		if (!this.hasAsOwning(ownable))			throw new IllegalOwnerException(ownable.getOwner(), ownable);		ownable.removeOwner();	}	/**	 * Link the given ownable to the ownings of this person.	 * 	 * @param   ownable	 *          The ownable to be linked.	 * @pre     This person may not have been terminated yet.	 *          | ! isTerminated()	 * @pre     The given ownable is effective and already references	 *          this person as its owner.	 *          | (ownable != null) && (ownable.getOwner() == this)	 * @pre     This person may not yet have the given ownable as	 *          one of its ownings.	 *          | (! hasAsOwning(ownable))	 * @post    This person has the given ownable as one of its	 *          ownings.	 *          | new.hasAsOwning(ownable)	 */	public void linkToOwnings(@Raw Ownable ownable) {		assert (ownable != null) && (ownable.getOwner() == this);		assert (!hasAsOwning(ownable));		ownings.add(ownable);	}	/**	 * Unlink the given ownable from the ownings of this person.	 * 	 * @param   ownable	 *          The ownable to be unlinked.	 * @pre     This person may not have been terminated yet.	 *          | ! isTerminated()	 * @pre     The given ownable is effective and references	 *          this person as its owner.	 *          | (ownable != null) && (ownable.getOwner() == this)	 * @pre     This person has the given ownable as one of	 *          its ownings.	 *          | hasAsOwning(ownable)	 * @post    This person no longer has the given ownable as	 *          one of its ownings.	 *          | (! new.hasAsOwning(ownable))	 */	public void unlinkFromOwnings(@Raw Ownable ownable) {		assert (ownable != null) && (ownable.getOwner() == this);		assert (hasAsOwning(ownable));		ownings.remove(ownable);	}	/**	 * Variable referencing a set collecting all the ownings of	 * this person.	 * 	 * @invar   The referenced set is effective, if and only if this	 *          person is terminated.	 *          | (ownings == null) == (this.isTerminated())	 * @invar   Each ownable registered in the referenced set is	 *          effective.	 *          | if (ownings != null)	 *          |   then (! ownings.contains(null))	 * @invar   Each ownable registered in the referenced set is	 *          not yet terminated.	 *          | for each ownable in Ownable:	 *          |   if ( (ownings != null) && (ownings.contains(ownable)) )	 *          |     then (!ownable.isTerminated())	 */	private Set<Ownable> ownings = new HashSet<Ownable>();	/**	 * Return the total value of all things owned by this person.	 *	 * @return  The total value of all things owned by this person.	 *          | result ==	 *          |   { ownable:Ownable |	 *          |     hasAsOwning(ownable) }}.getValue().sum()	 * @throws  IllegalStateException	 *          This person is already terminated.	 *          | isTerminated()	 */	public BigInteger getTotalValue() throws IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		BigInteger totalValue = BigInteger.ZERO;		for (Ownable owning : ownings)			totalValue = totalValue.add(owning.getValue());		return totalValue;	}	// The methods listed below illustrate different concepts offered in Java	// to retrieve information concerning the class to which an object belongs.	// None of the concepts is superior, meaning that each of the methods	// can be worked out just as well using the other concepts.	// In general, one must be very careful to use these concepts. As it will	// be discussed in later sessions, explicitly asking for the class to which	// an object belongs sometimes has a negative impact on the adaptability	// of software systems.	/**	 * Return the total amount of food needed to feed all dogs	 * owned by this person during the given number of days.	 *	 * @param   days	 *          The given number of days.	 * @return  The total amount of food needed to feed all dogs	 *          owned by this person during the given number of days.	 *          | let	 *          |   myDogs = { dog: Dog | hasAsOwning(dog) }	 *          | in	 *          |   result == {{ myDogs.getFoodAmount()*days }}.sum()	 * @throws  IllegalStateException [must]	 *          This person is already terminated.	 *          | isTerminated()	 * @throws  IllegalArgumentException [must]	 *          This person is not yet terminated and the given number of days	 *          is negative.	 *          | (! this.isTerminated()) && (days < 0)	 */	public BigInteger getTotalFoodAmount(int days)			throws IllegalArgumentException, IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		if (days < 0)			throw new IllegalArgumentException("Negative number of days!");		BigInteger totalDailyAmount = BigInteger.ZERO;		for (Ownable owning : ownings)			try {				// At this point, we use a type cast to verify whether the given owning				// is a dog. A ClassCastException is thrown, if the given owning turns				// out not to be dog (or an instance of a subclass of Dog).				Dog currentDog = (Dog) owning;				BigInteger currentDailyFoodAmount = BigInteger					.valueOf(currentDog.getDailyFoodAmount());				totalDailyAmount = totalDailyAmount.add(currentDailyFoodAmount);			}			catch (ClassCastException exc) {				assert (!(owning instanceof Dog));			}		return totalDailyAmount.multiply(BigInteger.valueOf(days));	}	/**	 * Return the car with the largest motor volume owned by this person.	 *	 * @return  The resulting car is owned by this person.	 *          | hasAsOwning(result)	 * @return  No other car owned by this person has a higher motor volume	 *          than the resulting car	 *          | for each car in Car:	 *          |   if (hasAsOwning(car))	 *          |     then result.getMotorVolume() >= car.getMotorVolume()	 * @throws  IllegalStateException [must]	 *          This person is already terminated.	 *          | isTerminated()	 * @throws  NoSuchElementException [must]	 *          This person is not yet terminated and does not own any car.	 *          | (! this.isTerminated()) &&	 *          | ( for each car in Car: (! hasAsOwning(car)) )	 */	public Car getMostPowerfulCar() throws NoSuchElementException,			IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		Car result = null;		for (Ownable owning : ownings)			// At this point, we use the operator instanceof, which checks whether the			// object at its left-hand side belongs to the class at its right-hand side.			// The null reference does not belong to any class, and an object of a class			// is also an instance of its superclass.			if (owning instanceof Car) {				Car currentCar = (Car) owning;				if ((result == null)					|| (result.getMotorVolume() < currentCar.getMotorVolume()))					result = currentCar;			}		if (result == null)			throw new NoSuchElementException("Person without cars!");		return result;	}	/**	 * Return a painting owned by this person and painted by the given painter.	 *	 * @param	painter	 *			The painter to search for.	 * @return	The resulting painting is owned by this person and painted	 *			by the given painter.	 *			| hasAsOwning(result) &&	 *			| result.getPainter() == painter	 * @throws	IllegalStateException [must]	 * 			This person is already terminated.	 * 			| isTerminated()	 * @throws	NoSuchElementException [must]	 *			This person is not yet terminated and does not own a painting	 *          by the given painter.	 *			| (! this.isTerminated()) &&	 *          | ( for each painting in Painting:	 *			|	  (painting.getPainter() != painter) ||	 *			|	  (! hasAsOwning(painting)) )	 */	public Painting getPaintingBy(Person painter)			throws NoSuchElementException, IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		for (Ownable owning : ownings) {			// At this point, we use some facilities of reflection as offered by Java.			// In Java, classes themselves are objects of the predefined class Class.			// The expression ClassName.class returns a reference to the object representing			// that class; the method getClass() returns a reference to the class to			// which the given object belongs.			// In this version it is important to use the method isAssignableFrom. If we			// had just written ==, an object of a subclass of the class Painting would not			// be taken into account then.			if (Painting.class.isAssignableFrom(owning.getClass())) {				Painting currentPainting = (Painting) owning;				if (currentPainting.getPainter() == painter)					return currentPainting;			}		}		throw new NoSuchElementException(			"Person without paintings of given painter!");	}	/**	 * Return the total value of all the things owned by this	 * person using the given extractor.	 *	 * @param   extractor	 *          The extractor to be used in evaluate all ownings of this person.	 * @return  The total amount returned by applying the given	 *          extractor to all things owned by this person.	 *          | result ==	 *          |   {{ extractor.getValueFor(ownable) in BigInteger |	 *          |          hasAsOwning(ownable) }}.sum()	 * @throws  IllegalStateException [must]	 *          This person is already terminated.	 *          | isTerminated()	 * @throws  IllegalArgumentException [must]	 *          This person us not yet terminated and the given extractor is	 *          not effective.	 *          | (! this.isTerminated()) && (extractor == null)	 */	public BigInteger getTotalFor(ownable.filters.BigIntegerExtractor extractor)			throws IllegalArgumentException, IllegalStateException {		if (extractor == null)			throw new IllegalArgumentException("Non-effective extractor!");		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		BigInteger total = BigInteger.ZERO;		for (Ownable owning : ownings)			total = total.add(extractor.getValueFor(owning));		return total;	}}